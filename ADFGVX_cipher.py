# template for encryption with the ADFGVX cipher
import random, string

ab = string.ascii_lowercase
dg = string.digits
ws = string.whitespace

morse = {'A':'•−−', 'D':'−••', 'F':'••−•', 'G':'−−•', 'V':'•••−', 'X':'−••−'}

scramble = "ph0qg64mea1yl2nofdxkr3cvs5zw7bj9uti8"

def genDict(scramble):
    # input: scramble is a single string of 36 characters
    # containing the scrambled letters of the alphabet and the 10 digits
    # e.g. "ph0qg64mea1yl2nofdxkr3cvs5zw7bj9uti8"
    # The function returns a dictionary
    # where the keys are the characters of scramble
    # and the values are 2-digit strings of letters from ADFGVX
    # e.g. d_sub = {'p':'AA', 'h':'AD', '0':'AF', etc}
    # the pairs of letters are generated by an algorithm
    
    s = 'ADFGVX'
    d_sub = {}

    scrambled = random.sample(scramble, len(scramble))

    digraphs = []

    j = 0
    while j != 6:
        for i in range(6):
            digraphs.append(s[i] + s[j])
        j += 1

    for i in range(36):
        d_sub[scrambled[i]] = digraphs[i]

    return d_sub

def genSubStream(pt, d_sub):
    # pt is the string of plaintext characters
    # whitespace and punctuation will be skipped
    # letters may be lower and uppercase
    # The function outputs a single string of uppercase letters
    # using the dictionary substituting characters with pairs of letters from ADFGVX
    # eg: if pt is "php", ct is "AAADAA"

    for char in pt:
        if char in string.whitespace or char in string.punctuation:
            pt = pt.replace(char, "")
    pt = pt.lower()
    
    ct = ""
    for char in pt:
        ct += d_sub[char]

    return ct

def split_chars(text, value):
    text = ''.join([str(char) for char in text if char not in string.whitespace])
    output = [text[i::value] for i in range(value)]
    return output

def genTable(kw, ct):
    # kw is a string (the keyword)
    # ct is a string (the output of the genSubStream function
    # the function generates a list of strings
    # corresponding to each row of the table
    # each row has as many characters as the keyword kw
    # for the last row, if too short, pad it with Xs
    # e.g. if kw = "cat", and ct = "ADDAVGFDAF"
    # then the function returns the list
    # t_ct = ['ADD', 'AVG', 'FDA', 'FXX']
    
    t_ct = [ct[i:i + len(kw)] for i in range(0, len(ct), len(kw))]

    if len(t_ct[len(t_ct)-1]) < len(t_ct[0]):
        difference = len(t_ct[0]) - len(t_ct[-1:]) - 1
        t_ct[len(t_ct)-1] += (difference + 1)*'X'

    return t_ct

def genOrder(kw):
    # returns a list of indexes corresponding to the indexes
    # of the letters of the keyword in ascending alphabetical order
    # for example, if keyword is "cat"
    # the function returns the list l_ind = [1, 0, 2]

    sorted_kw = ''.join(sorted(kw))

    l_ind = []
    for char in sorted_kw:
        l_ind.append(kw.index(char))

    return l_ind

def outputCol(l_ind, t_ct):
    # outputs a string
    # t_ct is a list of strings (the rows of the table)
    # l_ind is a list of indexes (the columns to read)
    # the output mimics reading the table by the sorted collumns
    # e.g. with l_ind =  [1, 0, 2] and t_ct = ['ADD', 'AVG', 'FDA', 'FXX']
    # the output will be 'DVDXAAFFDGAX'

    ct = ''
    i = 0

    while i != len(l_ind):
        for string in t_ct:
            ct += string[l_ind[i]]
        i += 1

    return ct

def genMorse(ct):
    # outputs a stream of dots, dashes, and spaces in a single strings
    # ct is a string of ADFGVX letters

    morse = {'A':'•−−', 'D':'−••', 'F':'••−•', 'G':'−−•', 'V':'•••−', 'X':'−••−'}

    mct = ''
    for char in ct:
        mct += morse[char] + ' '

    return mct

def main():
    # asks the user for the Plaintext
    pt = str(input("\nInput the plaintext here.")).lower()
    # asks the user for the Keyword
    kw = str(input("\nWhat is the keyword?")).lower()

    #finaltext = genMorse((outputCol(genOrder(kw), genTable(kw,genSubStream(pt,genDict(scramble))))))
    #finaltext = genTable(kw,genSubStream(pt,genDict(scramble)))

    print(genDict(scramble))

    return ''

main()